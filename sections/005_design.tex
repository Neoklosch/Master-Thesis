\acresetall

\chapter{Concept}\label{chapter:concept}
% This chapter introduces the architectural design of Component X. The component consists
% of subcomponent A, B and C.
% In the end of this chapter you should write a specification for your solution, including
% interfaces, protocols and parameters.
This chapter introduces the architectural design of plugin respect to the previously defined requirements.
Therefore the used development environment will be analyzed.
Followed by the initial architecture of the plugin to be developed.
Based on that the different layer of the system will be elaborated.

\section{Overview}
% The concept chapter provides a high-level explanation of your solution. Try to explain
% the overall structure with a picture. You can also use UML sequence diagrams for
% explanation.
% Figure 4.1 illustrates the situation between Alice and Bob. (sequence diagram from
% www.websequencediagrams.com)
\doit

% Docker Plugin as Vim Driver

\section{Development environment}
The choice of the development environment is crucial for the creation of a prototype.
It should be easy to used and fast to implement, but
The environemnt is important for both the implementation of the prototype, as well as the choice of possible plugins and libraries.
Futhermore the prefered environment from the \ac{FOKUS} has to be considered.
Thus, Open Baton is written in Java and is also partly ported to python and go.
Python in general is used for several projects at the \ac{FOKUS}.
Taking also the criterias from section \ref{section:technical-requirements} into account the following programming environments are applicable.
\doit

\textbf{Java:}

\textbf{Python:}

\textbf{Node.js:}

\textbf{Go:}

Due to the fact that python is used for several projects at the \ac{FOKUS} and... % TODO: finish that

The \ac{GUI} is a fundamental web client, which uses Angular.js as its main framework and some smaller tools like jQuery or the pretty famous bootstrap framework.

\section{Architecture of the system}
The overall architecture of the system can be seperated into two levels.
Figure \ref{fig:abstract_architecture_design} will point up the architecture.
The first level is the \textit{centralized fog level}.
This could be for example a cloud server or management node in a fog cluster.
Ideally this level should be implemented with an \ac{MANO} compliant framework.
Hereinafter Open Baton will referred as the tool of choice for that level.
Main function will be the creation of the \ac{NFVI} as well as the deployment of deployment plans for the \acp{NF}.
Open Baton will also have an overview of all existing nodes and can manage and maintain them.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{resources/images/initial_structure.png}
    \caption[Abstract architecture design]{Abstract architecture design}
    \label{fig:abstract_architecture_design}
\end{figure}
% TODO: check if applicaton manager is necessary

The second level is the \textit{autonomous fog level}.
The prototype to be developed will be located in this level.
It includes all existing fog nodes, as well as the prototype referenced as the \textit{OpenIoTFog Agent} in figure \ref{fig:abstract_architecture_design}.
Each node must have a running instance of the OpenIoTFog Agent to be part of the system.
Beside the prototype a node can have several hardware devices, sensors and actuators connected to them.
A virtualization infrastructure such as Docker or XEN, must be installed to be used by the prototype.
These infrastructure can create the containers and \acp{VNF}.
Further it is also possible to have additional third party tools installed which can interact with the them as well.

The OpenIoTFog Agent has several external connection points.
It has a \ac{REST} \ac{API} implemented to get some informations about the status of the fog node, as well as endpoints to receive the deployment plans from centralized fog level.
A \ac{MQTT} connection to a broker, which can be running in the centralized fog level as well as on any other fog node, is used for node discovery.
Finally there are some ZeroMQ endpoints for capability discovery, image deployment and node-to-node communication.
A detailed description will be shown in the following sections.

One of the most important components is the \textit{Local Orchestrator}.
It is responsoible for the deployment of the containers as well as the inter-node communication.
The latter is necessary to let the nodes act in an autonomously was, so that they can react to changing requirements, even when the centralized fog level disappears.
Therefore each node must have knowledge and should be able to interact with each other.
Beside that the local orchestrator is tightly coupled to the \textit{\ac{VAL} Manager}.
This is an abstraction layer for each virtualization component in the system, for example Docker or a bare-metal virtualization like XEN.
These components should be implemented as plugins, so that it is easy to add or remove virtualization components.
Therefore Yapsy\footnote{\url{http://yapsy.sourceforge.net/}} is used as the plugin system of choice.

The \textit{Hardware Event Handler} is a communication endpoint for other third party components.
For example an external hardware listener could send a message to the event handler to register a new connected device like a Zigbee dongle or a bluetooth stick.
This component should allow multiple third party components to send events to them.
Finally the \textit{Monitoring Agenct} is used to log all ongoing events and gives the maintainer of the system an overview of the system processes.
\todo{write more - probabyl about architecture MVC}
% MVC ohne View
% -> keine spezielle architektur
% -> jedoch decoupled as much as possible
% ---> DI, RxPy

\subsection{Virtualization layer}
The virtualization layer is basically an abstraction layer to generalize the different virtualization engines.
Therefore a so called \ac{VAL} manager which will be implemented with the facade design pattern is used to load the plugins and abstract the methods of the plugins.
As mentioned before to realize the plugin functionality the Yapsy library will be used.
The library offers a way to easily add new plugins to the system and is also designed to be easy to use.
It only depends on python standard libraries and lightweight by design.
Each supported virtualization engine needs his own concrete plugin implementation which should be use an interface to have a common ground.
The supported default engine is Docker, but could be extended in a future version of the prototype.

\subsection{Communication layer}
\label{subsection:CommunicationLayer}
The communication layer is a pretty important componant in the prototype.
Here three different communication points are necessary to provide the basic functionalities which are needed for the fog node agent.

The first subcomponent is the \textbf{node discovery}.
The idea behind the node discovery is that each node automatically can register and unregister himself to the cluster.
This means in the moment of the startup of a node, they will send out a message, with an information request about all subscribed nodes.
To realize that \ac{MQTT} will be the tool of choice.
The \ac{MQTT} broker will receive and forward the message to all subscribed nodes and each node will response with an information message to the broker again, which will send the message out again.
Therefore each node will be up-to-date at each time.
As long as there is no appearance or disappearance of any node, the network will not be stressed.
To provide a better flexibility the \ac{MQTT} broker can be executed in the centralized fog level or even on a node in the autonomous fog level.
This allows the system to operate even if the centralized fog level disappears due to network issues or any other communication problems.
It is also possible to let all nodes communicate which each other once they shared their information.
Smaller connection issues can be covered with this mechanism.
As the \ac{MQTT} broker Mosquitto\footnote{\url{https://mosquitto.org}} will be the tool of choice.
It is an eclipse\footnote{\url{http://www.eclipse.org}} project which means it is open source and under continous development.
The project website descibes themself as "a lightweight server implementation of the MQTT protocol that is suitable for all situations from full power machines to embedded and low power machines"\autocite{Eclipse:Mosquitto}.

The next subcomponent is the \textbf{inter- and intra-node communication}.
Both kinds of communication will be realised with ZeroMQ.
Some of the most important patterns and transport types in ZeroMQ was discribed in section \ref{section:ZeroMQ}.
For the node-to-node communication the \textit{Request-Reply} pattern via \ac{TCP} will be used.
Typical function calls would be the capability discovery where a node will request another node for their capabilities, the deployment or termination of an image on an external node and the request for an image status.
ZeroMQ allways requires an \ac{IP} to eastablish a connection to another node, therefore we had the node discovery which was described before.
This allows us to connect to any other node in the cluster.
In addition to the intra-node communication, also an inter-node communication will be implemented.
It will be used to add new capabilities to a node.
Therefore one or multiple third party applications should be connectable to a single ZeroMQ endpoint via the publish/subscribe pattern over \ac{IPC}.
Different to a normal publish/subscribe pattern, the endpoint will acts as the subscriber so that multiple publishers can push messages to them.
Beside that each exposed socket should be configurable via the configuration file.

The last subcomponent is the \textbf{\ac{REST} \ac{API}}.
It will be mainly used for the communication with the centralized fog level, because most of the orchestration tools out there are using \ac{REST} for transfering data.
In comparision to an implementation with ZeroMQ, this is much bigger overhead in terms of traffic and latency, but to have a better compatibility with other systems, this \ac{API} will be implemented.
As the tool of choice Flask\footnote{\url{http://flask.pocoo.org}} will be used.
It is a lightweight and robust python webserver, which is open source, well documented and under constant development.
The \ac{REST} \ac{API} himself will follow the \ac{HATEOAS} constraint with the addition that each endpoint will have a version number in the \ac{URL} to ensure backwards compatability if something changes in the implementation.

All the mentioned subcomponents should be controlled by a so called \textit{communication manager} which will be implemented with the facade design pattern.
That decouples the communiction layer from the other components, the whole system can be maintained much easier and each subcomponent can be easy replaced by any other technology if necessary.
This also makes the code more readable and leads up to a cleaner code strucutre.

\subsection{Data layer}
As mostly the data layer is used to persist necessary data.
This includes the deployed services, adjacent nodes and the capabilities of the node.
As database engine the lightweight document oriented database TinyDB\footnote{\url{http://tinydb.readthedocs.io}} will be used.
It stores the data into a single \ac{JSON} file, which means it has only very basic functionalities.
For example it does not support indexes or relationships and it is not optimised concerning performance.
But for it is easy to use, has no execution overhead and is good to use for small datasets.
The whole data layer should be as abstracted as all the other components before.
Therefore repositories for each content type will facade the tinydb methods and allows the underlaying library, in this case TinyDB, to be replaced easily and
without modifing several classes.
The configuration of the databases should be stored in the global config file as well.

\subsection{Capability Management}
The \textit{Capability Management} is used to create, persist, modify and remove the capabilities of the current node.
As mentioned before all the capabilities will be stored in the data layer via TinyDB.
Furthermore the \textit{Hardware Event Handler} is part of this layer.
It enables the system to get new capabilites from third party apps via a ZeroMQ endpoint.
As mentioned in the \ref{subsection:CommunicationLayer} the endpoint will be implemented as a form of the publish/subscribe pattern and should allow one or multiple publishers to push messages to the handler.
Also internal components like the \ac{VAL} plugins can add new capabilities to the system.

\subsection{Orchestration layer}
% ist primär für das Blueprint handling zuständig
% -> bekommt daten via api und parst diese
% -> guckt ob lokal deployed werden kann oder externe Node benötigt wird
% -> yaml als blueprint format
% sowie für die node-to-node Kommunikation
% -> Nodes registrieren sich beim starten der Engine
% -> können capabilities erfragen
% -> können container starten
% -> Sequenzdiagramme für die unterschiedlichen fälle erstellen
\doit

\subsection{User interface}
\doit

\subsection{Security}
% Access control
% Encryption of the communcation channels aka REST, ZeroMQ, MQTT
\doit

\subsection{Continuous Integration}
\doit

\section{Conclusion}
\doit




% http://getcloudify.org/brochures/Heavy%20Reading%20NFV%20MANO%20Cloudify%20Snapshot.pdf
