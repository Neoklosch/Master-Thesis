\chapter{Requirements Analysis}
\label{chapter:requirements-analysis}
% This section determines the requirements necessary for X. This includes the functional
% aspects, namely Y and Z, and the non functional aspects such as A and B.
Based on the fundamentals the requirements for the plugin to be developed will be formulated in this chapter.
Thereby aspects that will be relevant for the specific implementation will be considered.

% In this chapter you will describe the requirements for your component. Try to group the
% requirements into subsections such as ’technical requirements’, ’functional requirements’,
% ’social requirements’ or something like this. If your component consist of different partial
% components you can also group the requirements for the corresponding parts.
% Explain the source of the requirements.
% Example: The requirements for an X have been widely investigated by Organization
% Y.
% In his paper about Z, Mister X outlines the following requirements for a Component
% X

\section{Technical requirements}
\label{section:technical-requirements}
% virtualization
As the fundamental requirement, the prototype to be developed has to create, manage and maintain virtualized containers on a fog node.
Tools like Open Baton inherently supports OpenStack as the \ac{ETSI} \ac{MANO} \ac{VIM} layer.
Most \ac{MANO} tools like Open Baton uses OpenStack which deploys virtual machines to virtualize the \acp{NF}.
This is a rock solid solution for a cloud environment.
Unfortunately a bare-metal virtualization is most of the times not feasible on small power devices like they are used in the \ac{IoT} area.
Therefore OpenStack should be replaced by a more efficient and lightweight solution like container virtualization.
The desired \acp{NF} can be bundeled in one or multiple containers and executed afterwards on the expected \ac{IoT} nodes.
Such a bundle of containers should be passed to the node as a build plan or a blueprint of the service.
The fog node engine should accept the blueprint and deploy the containers to the desired virtualization layer.
Afterwards the lifecylce of the services should be monitored.

% constraints
The second functional requirement is the implementation of a constraint logic which will be used to filter relevant nodes during the \ac{NF} orchestration.
A constraint can be a functional and non-functional constraint.
For example a specific hardware component, like a sensor or a ZigBee dongle, which is necessary to execute the \ac{NF} or a hardware requirement, like \ac{CPU} power, \ac{RAM} or disk space.
It could also be a non-functional constraint, for example a specific software which has to be installed or a protocal which can be used.
The local orchestrator should manage these constraints for itself and if necessary for all adjacent nodes and should consider them while choosing a suitable nodes for the desired \ac{NF}.
The whole functionality should work similar to the labels in Docker Swarm.
There a Docker Swarm node can be have multiple labels, which can be considered when deploying an image.
This behavior should be achieved by the fog node engine.
% images should be found by the registry?
% should only the server have these information or should the node himself have the infromations/schema and can provide it?

Some side conditions should also be fulfilled.
The whole system should be modular and easy to extend.
Modules should be as decoupled as possible and the whole system should be controled via an \ac{API}.
The centralized cloud environment should be easiely replacable and should not be exclusively bound to Open Baton.
Finally the whole system should be well tested and documented.


\section{Functional requirements}
\label{section:functional-requirements}
% prototype behavior
After the general conditions for the prototype has been defined, the functional requirements will also be addressed.
When selecting the programming environment special attention is paid to the compatibility of the Open Baton framework. % TODO: was noch?
This is particularly important as the effort to develop a prototype should be a s small as possible and the prototype should be natively applicable on the fog nodes.
Open Baton has an build in plugin mechanism, which allows to replace for example the \ac{VIM} driver or the \ac{VNFM} so that any third party tool can be accessed via an \ac{API}.
Because Open Baton and the whole environment around them is open source, it would be also feasible to extend the system if necessary, but with the addition, that the system still follows the \ac{ETSI} \ac{MANO} conventions.
Beside that the prototype should be flexible enough to also fit in any other system by providing an \ac{API} to control the system.

% GUI beahvior
Additional it would be useful to create a \ac{GUI} for interacting with the prototype and show the functionallity of the system.
This should only be a simple \ac{GUI} for testing and demonstration purposes and should not be necessary for executing the final prototype.
Later on the prototype should be controlled via the \ac{API} from any other existing orchestration tool.
A command line tool to control the system would be useful as well and eases the handling of the prototype.
% TODO: probably more?

\section{Use-Case-Analysis}
\label{section:use-case-analysis}
\doit
% Deploy VNFs in factory (e.g. mass production, tracking of stuff)
% ad hoc deployment if truck arives at factory
% detect the right nodes, e.g. software needs specific sensor or latency
% Sequenzdiagramm für Ablauf vom Deployment bis zum container: IMG_20170526_201659.jpg

\section{Delineation from existing solutions}
\label{section:delineation-from-existing-solutions}
\todo{Rework that section}
This section is intended to show the features of existing systems and the main differences will be highlighted.
As mentioned before, the prototype to be developed should orchestrate virtualized containers on nodes based on functional and non-functional constraints.
Therefore the focus of this consideration is the orchestration as well as the constraints.

\paragraph{Kubernetes} is especially made for Docker and can orchestrate, scale and manage containers.
It is open source, made by Google and one of the most popular orchestration tools out there.
It has on huge and pretty active community and is used by several well known companies\autocite{Kubernetes:Case-Studies} like ebay\footnote{\url{http://www.ebay.com}} and Wikimedia\footnote{\url{https://www.wikimedia.org}}.
Due to the fact, that is exclusivly made for Docker, it means that the system is not made to easily switch the underlying container engine if needed.

As mentioned in section \ref{subsection:state-of-the-art:kubernetes} Kubernetes supports labels.
These are simple key-value pairs provided as \ac{JSON} objects which can be added by the system administrator to a Kubernetes Object like a pod or a service.
The labels are stored on the Kubernetes Master and can be used to filter specific pods or services during the deployment phase.
This behavior is pretty close to the one which should be achieved.

Kubernetes is made for the cloud, which means it is not inteded to be used on low power devices.
There are some trials to do so, but until know it is not used in a productive \ac{IoT} environment.
Forthermore Kuberenetes is not \ac{ETSI} \ac{MANO} compliant, but provides an easy to use web \ac{UI}.

\paragraph{Docker Swarm} is pretty similar to Kubernetes from a functional point of view, which means it has nearly the same pros and cons.
It is open source as well, has a quite active community and it is also made exclusivly for Docker.
Biggest benefit compared to Kubernetes is, that it is build the Docker Engine.
No separate installation is necessary and it can be used out of the box.

Also in terms of labels, both platforms are similar.
Docker Swarm uses labels in the same way Kubernetes is using them.
The user can add them during the initialization phase or edit them during runtime.
They are also key-value pairs or alternatively keys only.
By default labels can not be predefined in a \ac{JSON} file and applied to the node afterwards.
The placement have to be done by hand via the Docker client or the \ac{REST} \ac{API}.

Just as Kubernetes, Docker Swarm is not \ac{ETSI} \ac{MANO} compliant and provides no build-in \ac{GUI}, but there are several third party tools out in the market.
Due to the fact that it is a build-in function of Docker, the setup is quite easy and much more lightweight than Kubernetes.
This means it will also work on \ac{IoT} devices by default.

\paragraph{OpenStack}
% VMs only -> my system much more lightweight -> optimal for IoT area
% complicated -> huge setup effort -> several tools have to be configured
% is suitable for NFVs not for IoT
\doit

\paragraph{Cloudify} is completely compatible to the \ac{ETSI} \ac{MANO} standard and can be used as the \ac{NFVO}, as well as the generic \ac{VNFM} of this architecture.\cite[cf.]{Cloudify:MANO}
It is also able to interact with multiple \acp{VIM}, containers, infrastructures and devices and due to the fact that it can be extended with plugins, it is can be used together with several well known tools like OpenStack, Docker or even Kubernetes.\cite[cf.]{Cloudify:MANO}
Through these flexibility Cloudify can also be used in an \ac{IoT} envoironment if an appropriate \acp{VIM} plugin is used.
Downside is that Cloudify himself is very limited without a powerfull underlaying orchestration tool.

By default it is also not possible to orchestrate functionalities based on constraints.
To enable this behavior the used plugin has to support such a functionality like Docker Swarm or Kubernetes.
Cloudify provides an easy to use \ac{GUI} where the user can use the whole system, as well as a clean commandline tool.
By using \ac{YAML} files to build blueprints based on the \ac{TOSCA} standard, the creation of such a blueprint is similar to well known workflows like the creation of a Ansible or Vagrant deployment schema.
With the help of the Cloudify Composer the creation of a blueprint is getting much easier and also usable for users without any coding experience.

% https://www.sdxcentral.com/products/gigaspace-cloudify/


\section{Conclusion}
\label{section:requirements-conclusion}
\doit
