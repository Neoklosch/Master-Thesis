\acresetall

\chapter{Requirements Analysis}\label{chapter:requirements-analysis}
% This section determines the requirements necessary for X. This includes the functional
% aspects, namely Y and Z, and the non functional aspects such as A and B.
Based on the fundamentals the requirements for the plugin to be developed will be formulated in this chapter.
Thereby aspects that will be relevant for the specific implementation will be considered.

% In this chapter you will describe the requirements for your component. Try to group the
% requirements into subsections such as ’technical requirements’, ’functional requirements’,
% ’social requirements’ or something like this. If your component consist of different partial
% components you can also group the requirements for the corresponding parts.
% Explain the source of the requirements.
% Example: The requirements for an X have been widely investigated by Organization
% Y.
% In his paper about Z, Mister X outlines the following requirements for a Component
% X

\section{Technical requirements}
% virtualization
As the fundamental requirement, the prototype to be developed has to be based on the Open Baton Framework.
Open Baton inherently supports OpenStack as the \ac{ETSI} \ac{MANO} \ac{VIM} layer.
By default OpenStack useses virtual machines to enable facilitate the virtualization of the \acp{NF}.
This is a rock solid solution for a cloud environment.
Unfortunately a bare-metal virtualization is most of the times not feasible on small power devices like they are used in the \ac{IoT} area.
Therefore OpenStack should be replaced by a more efficient and lightweight solution like container virtualization.
The desired \acp{NF} can be bundeled in a container and can be executed afterwards on the expected \ac{IoT} nodes.
The implementation of a container virtualization \ac{VIM} layer should be possible by the Open Baton build in plugin system.
It allows to add new functionalities to the system by extending a component, in this case the \ac{VIM} driver and the \ac{VNFM}.

% constraints
The second functional requirement is the implementation of a constraint logic which will be used to filter relevant nodes during the \ac{NF} orchestration.
A constraint can be a functional and non-functional constraint.
For example a specific hardware component, like a sensor or a ZigBee dongle, which is necessary to execute the \ac{NF} or a hardware requirement, like \ac{CPU} power, \ac{RAM} or disk space.
It could also be a non-functional constraint, for example a specific software which has to be installed or a protocal which can be used.
Open Baton as the central management system should manage these constraints for all conected nodes and should consider them while choosing suitable nodes for the desired \ac{NF}.
The whole functionality should work similar to the labels in Docker Swarm.
There a Docker Swarm node can be have multiple labels, which can be considered when deploying an image.
This behavior should be achieved by the plugin.
% images should be found by the registry?
% should only the server have these information or should the node himself have the infromations/schema and can provide it?


\section{Functional requirements}
% Plugin behavior
After the general conditions for the plugin has been defined, the functional requirements will also be addressed.
When selecting the programming environment special attention is paid to the compatibility of the Open Baton framework.
This is particularly important as the effort to develop a prototype should be a s small as possible and the plugin should be immediately applicable.
Open Baton has an build in plugin mechanism, which allows to replace for example the \ac{VIM} driver or the \ac{VNFM}.
Because Open Baton is open source, it would be also feasible to extend the system if necessary, but with the addition, that the system still follows the \ac{ETSI} \ac{MANO} conventions as a secondary goal.

% GUI beahvior
Open Baton also provides a \ac{GUI} as well as a command line tool to control the system.
Even the plugin and all the related functionalities should be controlled and monitored via the given tools.
This shortening the learning curve and reducing training demands for the enduser.
The system can be used in the same way as the user is used to.

\section{Use-Case-Analysis}
\doit
% Deploy VNFs in factory (e.g. mass production, tracking of stuff)
% ad hoc deployment if truck arives at factory
% detect the right nodes, e.g. software needs specific sensor or latency

\section{Delineation from existing solutions}
This section is intended to show the features of existing systems and the main differences will be highlighted.
As mentioned before, the plugin to be developed should orchestrate virtualized containers to nodes based on functional and non-functional constraints.
Therefore the focus of this consideration is the orchestration as well as the constraints.

\textbf{Kubernetes} is especially made for Docker and can orchestrate, scale and manage containers.
It is open source, made by Google and one of the most popular orchestration tools out there.
It has on huge and pretty active community and is used by several well known companies\cite{Kubernetes:Case-Studies} like ebay\footnote{\url{http://www.ebay.com}} and Wikimedia\footnote{\url{https://www.wikimedia.org}}.
Due to the fact, that is exclusivly made for Docker, it means that the system is not made to easily switch the underlying container engine if needed.

As mentioned in section \ref{subsection:state-of-the-art:kubernetes} Kubernetes supports labels.
These are simple key-value pairs which can be added by the system administrator to a Kubernetes Object like a pod or a service.
The labels are stored on the Kubernetes Master and can be used to filter specific pods or services during the deployment phase.
This behavior is pretty close to the one which should be achieved.

Kubernetes is made for the cloud, which means it is not inteded to be used on low power devices.
There are some trials to do so, but until know it is not used in a productive \ac{IoT} environment.
Forthermore Kuberenetes is not \ac{ETSI} \ac{MANO} compliant.

\textbf{Docker Swarm}
% not MANO compliant
% no gui
% limited support for constraints -> only labels

% Cloudify (what else?)
% not MANO compliant
% no constraints

% OpenStack
% VMs only -> my system much more lightweight -> optimal for IoT area
% complicated -> huge setup effort -> several tools have to be configured
% is suitable for cloud not for IoT

\section{Conclusion}
\doit
